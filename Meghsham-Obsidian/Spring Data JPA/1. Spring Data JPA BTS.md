## Technology Stack Hierarchy

```
┌─────────────────────────────────────────────────────────────┐
│                 Spring Boot Application                     │
├─────────────────────────────────────────────────────────────┤
│                 Spring Data JPA                             │
├─────────────────────────────────────────────────────────────┤
│                 Spring Data Commons                         │
├─────────────────────────────────────────────────────────────┤
│                 JPA (Java Persistence API)                  │
├─────────────────────────────────────────────────────────────┤
│                 Hibernate (JPA Implementation)              │
├─────────────────────────────────────────────────────────────┤
│                 JDBC (Java Database Connectivity)           │
├─────────────────────────────────────────────────────────────┤
│                 Database (MySQL, PostgreSQL, etc.)          │
└─────────────────────────────────────────────────────────────┘
```

## 1. JDBC (Java Database Connectivity)

Is the Foundation Layer which is at Lowest level database connectivity API in Java and is part of Java SE (Standard Edition) providint basic database operations.

### Pros

-Full control over SQL and database operations
-Best performance for complex queries
-No magic - you see exactly what happens

### Cons

- Verbose code - lots of boilerplate
- Manual resource management (connections, statements, result sets)
- No object-relational mapping
- Error-prone (forget to close resources, SQL injection risks)

## 2. Hibernate

It is Object-Relational Mapping (ORM) Framework has JPA implementation (most popular one) that maps Java objects to database tables and Handles object-relational impedance mismatch.

1. Get JDBC connection from connection pool
2. Create prepared statement
3. Execute query
4. Map ResultSet to Java object (reflection)
5. Close resources

### Pros

-Reduces boilerplate compared to JDBC
-Automatic object-relational mapping
-Caching (first and second level)
-Lazy loading, relationships management

### Cons

- Learning curve - need to understand session management, states
- Performance overhead for simple queries
- Magic - sometimes hard to debug what SQL is generated

## 3. JPA (Java Persistence API)

JPA is The Specification/Standard for ORM which defines interfaces and annotations (@Entity, @Id, @Column, etc.) and Hibernate implementing JPA specification. There are other implementations like EclipseLink, OpenJPA.

### Relationship: JPA Vs Hibernate

```
JPA = Interface/Standard
Hibernate = Implementation of that interface

Similar to:
List<String> list = new ArrayList<>();
JPA = List interface
Hibernate = ArrayList implementation
```

## 4. Spring Data JPA

Is a abstraction Layer on Top of JPA is part of Spring Data family provides Repository abstraction on top of JPA. It Reduces boilerplate even further and automatic query generation from method names With Spring Data JPA - No implementation needed as Spring Data JPA implements this automatically!

## 5. Spring Boot Data JPA

- Spring Boot Data JPA is Spring Boot module which is an abstraction on Spring Data JPA
- Gives Auto-Configuration which sets up everything automatically and is Starter which act as default pre-configured bundles of dependencies and simplified dependency management for Spring Boot Project over Minimal configuration needed

### What Spring Boot Auto-Configures:

Spring Boot automatically creates:

1. `DataSource` (Connection pool - HikariCP)
2. `EntityManagerFactory` (JPA)
3. `TransactionManager`
4. Spring Data JPA repositories

## Complete Flow Example

### Database Operation Flow:

```
1. Your Code: userRepository.findById(1L)
2. Spring Data JPA: generates JPA call
3. JPA: EntityManager.find(User.class, 1L)
4. Hibernate: Session.get(User.class, 1L)
5. JDBC: Executes "SELECT * FROM users WHERE id = 1"
6. Database: Returns result set
7. JDBC: Converts to ResultSet
8. Hibernate: Maps ResultSet to User object
9. JPA: Returns User entity
10. Spring Data JPA: Wraps in Optional
11. Your Code: Gets User object
```

## Code Comparison

### Same Operation - Different Levels:

```java
1. Pure JDBC
public User findUserJDBC(Long id) throws SQLException {
    Connection conn = dataSource.getConnection();
    PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
    stmt.setLong(1, id);
    ResultSet rs = stmt.executeQuery();
    ... manual mapping and resource cleanup
}

2. Hibernate Native
public User findUserHibernate(Long id) {
    Session session = sessionFactory.openSession();
    User user = session.get(User.class, id);
    session.close();
    return user;
}

3. JPA Standard
public User findUserJPA(Long id) {
    EntityManager em = emf.createEntityManager();
    User user = em.find(User.class, id);
    em.close();
    return user;
}

4. Spring Data JPA
public User findUserSpringDataJPA(Long id) {
    return userRepository.findById(id).orElse(null);
}

5. Spring Boot + Spring Data JPA
Just declare the interface - everything else auto-configured!
```

## When to Use What?

### Use Pure JDBC When:

- Complex SQL queries with database-specific features
- Performance-critical bulk operations
- Stored procedure calls
- Legacy systems integration

### Use Hibernate Native When:

- Non-Spring applications needing ORM
- Advanced Hibernate features not in JPA spec
- Custom legacy applications

### Use JPA When:

- Vendor neutrality - want to switch implementations
- Standard-based approach
- Enterprise applications following standards

### Use Spring Data JPA When:

- Rapid development - reduce boilerplate
- Standard CRUD operations
- Spring ecosystem applications
- Team productivity focus

### Use Spring Boot Data JPA When:

- Microservices
- Cloud-native applications
- Quick prototyping
- Production-grade applications with minimal configuration

## Performance Considerations

```java
// JDBC - Most control, best performance for complex operations
// JDBC gives you full control over complex SQL
String complexSQL = """
    WITH ranked_orders AS (
        SELECT *, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) as rn
        FROM orders
    )
    SELECT * FROM ranked_orders WHERE rn = 1
    """;

// Lazy loading - be careful of N+1!
Hibernate/JPA - Better for object navigation
User user = userRepository.findById(1L);
List<Order> orders = user.getOrders();


// Spring Data JPA - Best for standard CRUD
Page<User> users = userRepository.findByActiveTrue(PageRequest.of(0, 20));
```

## Summary

For most Spring Boot applications:

```
You use Spring Boot Data JPA →
which uses Spring Data JPA →
which uses JPA →
which uses Hibernate →
which uses JDBC →
which connects to your Database.
```
