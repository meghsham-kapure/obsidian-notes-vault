A **Queue** is a linear data structure that follows the **First-In-First-Out (FIFO)** principle, where elements are added at one end (called the **rear** or **tail**) and removed from the other end (called the **front** or **head**). It operates like a real-world queue, such as people waiting in line at a ticket counter, where the first person in line is served first.

---



![[queue_ds.png]]
### **Key Characteristics**
- **FIFO Order**: The first element added is the first to be removed.
- **Dynamic Size**: The size of a queue can grow or shrink as elements are added or removed (in most implementations).
- **Two Ends**: Operations occur at opposite ends (rear for insertion, front for deletion).
- **Abstract Data Type (ADT)**: A queue defines a set of operations without specifying how they are implemented.

---
## **Types of Queues**
There are several variations of queues, each suited for specific use cases:

### **a. Simple Queue (Linear Queue)**
- A basic queue that follows the FIFO principle.
- Elements are added at the rear and removed from the front.
- Can be implemented using arrays or linked lists.
- **Limitation**: In array-based implementations, once the rear reaches the end of the array, no more elements can be added (even if the front is empty) unless the queue is shifted.

### **b. Circular Queue**
- A variation of the simple queue where the rear and front are connected to form a circle.
- When the rear reaches the end of the array, it wraps around to the beginning (if space is available).
- **Advantage**: Efficient use of space, as it reuses the empty spaces left by dequeued elements.
- Commonly used in scenarios with fixed-size buffers, like in operating systems or data streaming.

### **c. Priority Queue**
- Elements are assigned priorities, and the element with the highest priority (or lowest, depending on the implementation) is removed first, regardless of the order of insertion.
- **Implementation**: Often implemented using heaps or binary search trees.
- **Applications**: Task scheduling, Dijkstra’s algorithm, etc.

### **d. Deque (Double-Ended Queue)**
- A queue where elements can be added or removed from both the front and the rear.
- Variants:
  - **Input-Restricted Deque**: Insertion is allowed only at one end, but deletion is allowed at both ends.
  - **Output-Restricted Deque**: Deletion is allowed only at one end, but insertion is allowed at both ends.
- **Applications**: Undo operations in software, palindrome checking, etc.

---

## **Basic Operations on Queue**
The following are the primary operations supported by a queue:

### **a. Enqueue (Insert)**
- Adds an element to the rear of the queue.
- Time Complexity: O(1) for both array and linked list implementations.
- **Condition**: If the queue is full (in array-based implementations), an overflow error occurs.

### **b. Dequeue (Delete)**
- Removes and returns the element at the front of the queue.
- Time Complexity: O(1) for both array and linked list implementations.
- **Condition**: If the queue is empty, an underflow error occurs.

### **c. Peek (Front)**
- Returns the element at the front without removing it.
- Time Complexity: O(1).
- **Condition**: If the queue is empty, it may return an error or a special value.

### **d. IsEmpty**
- Checks if the queue is empty.
- Time Complexity: O(1).
- Returns `true` if no elements are present, `false` otherwise.

### **e. IsFull**
- Checks if the queue is full (relevant for array-based implementations).
- Time Complexity: O(1).
- Returns `true` if the queue has reached its maximum capacity, `false` otherwise.

### **f. Size**
- Returns the number of elements in the queue.
- Time Complexity: O(1) if maintained explicitly, O(n) if counted in a linked list.

---
## **Time and Space Complexity**
| Operation       | Array-Based | Linked List-Based |
|-----------------|-------------|-------------------|
| Enqueue         | O(1)        | O(1)              |
| Dequeue         | O(1)        | O(1)              |
| Peek            | O(1)        | O(1)              |
| IsEmpty         | O(1)        | O(1)              |
| IsFull (array)  | O(1)        | N/A               |
| Space Complexity| O(n)        | O(n)              |

- **n** is the number of elements in the queue.
- Array-based queues have a fixed capacity, while linked list-based queues are dynamic.

---

## **Applications of Queue**
Queues are widely used in computer science and real-world scenarios, including:

### **a. Operating Systems**
- **Process Scheduling**: Queues manage processes in CPU scheduling (e.g., ready queue).
- **I/O Buffers**: Queues handle input/output operations, such as keyboard or printer buffers.

### **b. Networking**
- **Packet Queuing**: Routers and switches use queues to manage data packets.
- **Message Queues**: Used in messaging systems for asynchronous communication.

### **c. Algorithms**
- **Breadth-First Search (BFS)**: Queues are used to explore nodes level by level in graphs or trees.
- **Sliding Window Problems**: Queues (or deques) maintain elements in a window.

### **d. Real-World Applications**
- **Task Management**: Queues manage tasks in systems like call centers or ticket booking.
- **Simulation Systems**: Queues simulate real-world scenarios, such as customer service lines.
- **Print Spooling**: Printers use queues to manage print jobs.

### **e. Priority Queues**
- **Event-Driven Simulation**: Priority queues manage events based on their timestamps.
- **Shortest Path Algorithms**: Used in Dijkstra’s or Prim’s algorithms.

---

## **7. Advantages of Queue**
- Efficient for FIFO-based operations.
- Simple to implement and understand.
- Supports dynamic resizing (in linked list-based implementations).
- Versatile, with variations like circular queues and priority queues for specific needs.

## **8. Disadvantages of Queue**
- **Array-Based**:
  - Fixed size leads to potential overflow.
  - Space wastage in simple queues (mitigated by circular queues).
- **Linked List-Based**:
  - Extra memory overhead for pointers.
  - No random access to elements.
- Limited functionality compared to other data structures like stacks or deques.
- Priority queues may require more complex implementations (e.g., heaps).

---

## **9. Comparison with Other Data Structures**
| Feature         | Queue (FIFO)       | Stack (LIFO)       | Deque              |
|-----------------|--------------------|--------------------|--------------------|
| Insertion       | Rear only          | Top only           | Both ends          |
| Deletion        | Front only         | Top only           | Both ends          |
| Use Case        | BFS, scheduling    | DFS, backtracking  | Flexible operations|
| Complexity      | O(1) for main ops  | O(1) for main ops  | O(1) for main ops  |

---

## **10. Example Problems Using Queues**
1. **Reverse a Queue**: Use a stack to reverse the order of elements in a queue.
2. **Sliding Window Maximum**: Use a deque to find the maximum element in each window of size k.
3. **Level Order Traversal of a Binary Tree**: Use a queue to print nodes level by level.
4. **Josephus Problem**: Use a circular queue to simulate the elimination process.

---

## **11. Conclusion**
A queue is a fundamental data structure that excels in scenarios requiring FIFO processing. Its simplicity, efficiency, and versatility make it a cornerstone of computer science, with applications ranging from operating systems to algorithm design. By understanding its variations (e.g., circular, priority, deque) and implementation details, developers can choose the right queue type for their specific needs.

