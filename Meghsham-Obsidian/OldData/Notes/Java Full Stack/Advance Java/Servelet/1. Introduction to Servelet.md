A **Servlet** is a Java-based technology used for building dynamic web applications. It acts as a middle layer between client requests (typically from a web browser or sometimes Postman) and the server's response. Servlets are a part of the **Java EE (Jakarta EE)** platform and run on a servlet container such as **Apache Tomcat, Jetty, or WildFly**.

#### **Key Features of Servlets:**

- **Platform-independent:** Since servlets are written in Java, they can run on any platform with a compatible servlet container.
- **Efficient and Scalable:** Unlike traditional CGI scripts, servlets use a multithreading model, handling multiple client requests within the same process.
- **Secure:** They support authentication, authorization, and encryption mechanisms.
- **Integration with Java EE Technologies:** Servlets work seamlessly with JSP, JDBC, and other Java-based web technologies.

#### **How Servlets Work?**

1. **Client Request:** The user sends an HTTP request (GET/POST) from a web browser.
2. **Servlet Container:** The container (e.g., Tomcat) receives the request and forwards it to the appropriate servlet.
3. **Processing:** The servlet processes the request, interacts with the database if necessary, and generates a response.
4. **Response Generation:** The servlet sends the response (HTML, JSON, XML, etc.) back to the client.
	![[Servlet Working.png]]
----
### **Lifecycle of a Servlet in Java**

The **Servlet Lifecycle** defines the stages a servlet goes through from creation to destruction. It is managed by the **Servlet Container** (e.g., Tomcat, Jetty, WildFly) and consists of three main phases:
![[Servlet Life Cycle.png]]

1. **Instantiation (Object Creation)**
2. **Initialization (`init()` method)**
3. **Request Handling (`service()` method, including `doGet()` and `doPost()`)**
4. **Destruction (`destroy()` method)**

### **1. Servlet Instantiation (Object Creation)**

- The servlet container loads the servlet class and creates an instance of it.
- This happens only **once** when the servlet is first requested or at server startup (if configured for loading at startup).
- The servlet object is **not recreated** for every request.

### **2. Initialization (`init()` method)**

- The container calls the `init()` method only **once** when the servlet is first loaded.
- This method is used for **initial setup** like loading configurations, database connections, etc.

**Example:**

```java
@Override
public void init() throws ServletException {
    System.out.println("Servlet is being initialized...");
}
```

### **3. Request Handling (`service()` method)**

- After initialization, the servlet is ready to handle client requests.
- The container calls the `service()` method for each request.
- The `service()` method determines the request type (`GET`, `POST`, etc.) and calls the corresponding method (`doGet()`, `doPost()`).

**Example:**

```java
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException {
    response.setContentType("text/html");
    PrintWriter out = response.getWriter();
    out.println("<h1>Hello, Servlet!</h1>");
}
```

### **4. Destruction (`destroy()` method)**

- When the servlet is no longer needed (e.g., server shutdown, undeployment), the container calls the `destroy()` method.
- This method is used to **release resources** like database connections or file handles.

**Example:**

```java
@Override
public void destroy() {
    System.out.println("Servlet is being destroyed...");
}
```

----
### **Ways to Create a Servlet in Java Using Classes**

In Java, there are **three main ways** to create a servlet using classes:

1. **By Extending `HttpServlet` (Recommended Approach)**
2. **By Implementing `Servlet` Interface**
3. **By Extending `GenericServlet` Class**

---

## **1. By Extending `HttpServlet` (Most Common Method)**

- `HttpServlet` is a subclass of `GenericServlet` designed specifically for HTTP-based requests.
- You only need to override `doGet()` or `doPost()` methods based on the request type.

### **Example:**

```java
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/hello") // Annotation-based configuration
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<h1>Welcome to Servlet!</h1>");
    }
}
```

**Deployment:**

- Place this class inside the `src` folder of a Java web project.
- Run on a servlet container like **Apache Tomcat**.

---

## **2. By Implementing `Servlet` Interface**

- This is a **low-level approach** requiring you to implement all lifecycle methods manually (`init()`, `service()`, `destroy()`).
- It gives more control but is **not commonly used** due to increased complexity.

### **Example:**

```java
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.*;

public class MyServlet implements Servlet {
    ServletConfig config = null;

    @Override
    public void init(ServletConfig config) throws ServletException {
        this.config = config;
        System.out.println("Servlet Initialized...");
    }

    @Override
    public void service(ServletRequest request, ServletResponse response) 
            throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<h1>Servlet using Servlet Interface</h1>");
    }

    @Override
    public void destroy() {
        System.out.println("Servlet Destroyed...");
    }

    @Override
    public ServletConfig getServletConfig() {
        return config;
    }

    @Override
    public String getServletInfo() {
        return "Basic Servlet Implementation";
    }
}
```

**Deployment:**

- Define the servlet in `web.xml`:

```xml
<servlet>
    <servlet-name>MyServlet</servlet-name>
    <servlet-class>MyServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>MyServlet</servlet-name>
    <url-pattern>/myServlet</url-pattern>
</servlet-mapping>
```

- Access the servlet via `http://localhost:8080/YourApp/myServlet`.

---

## **3. By Extending `GenericServlet` Class**

- `GenericServlet` is a **protocol-independent** class that can handle any type of request (not just HTTP).
- However, it is **less common** because most web applications are **HTTP-based**.

### **Example:**

```java
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.*;

public class MyGenericServlet extends GenericServlet {
    @Override
    public void service(ServletRequest request, ServletResponse response) 
            throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<h1>Servlet using GenericServlet Class</h1>");
    }
}
```

**Deployment:**

- Configure it in `web.xml` (similar to the previous example).

---

## **Comparison of Approaches**

|Approach|Extends/Implements|Pros|Cons|
|---|---|---|---|
|**Extending `HttpServlet`** (Recommended)|`HttpServlet`|Simplifies HTTP request handling (`doGet()`, `doPost()`)|Less control over servlet lifecycle|
|**Implementing `Servlet`**|`Servlet`|Full control over lifecycle methods|Requires implementing all methods manually|
|**Extending `GenericServlet`**|`GenericServlet`|Can handle non-HTTP requests|Requires manual request handling|

---